import amqp from 'amqp-connection-manager'
import config from './config'

const logger = global.logger || console

function getRandomFirstArray(arr) {
  const array = arr.slice()
  const i = Math.floor(Math.random() * (array.length))
  const randomOne = array.splice(i, 1)
  return [randomOne].concat(array)
}

/**
 * channelConfigs: [channelConfig]
 * channelConfig: {exchange: {name, type, options},
 * queue: {name, assertOptions, bindOptions}, consume: {consumeHandler, options}, routingKey}
 */
export default async ({ vhost, channelConfigs = [] }) => {
  const { amqpDomains } = config
  const urls = getRandomFirstArray(amqpDomains).map(amqpDomain => `${amqpDomain}/${vhost}`)

  try {
    const connection = await amqp.connect(urls)
    connection.on('connect', () => logger.info(`Connected!-------rabbit mq in vhost ${vhost}`))
    connection.on('disconnect', params => logger.info(`Disconnected-----rabbit mq in vhost ${vhost}`, params.err.stack))

    const channelWrapper = connection.createChannel()

    channelConfigs.forEach(({ exchange, queue, consume, routingKey }) => {
      channelWrapper.addSetup(async channel => {
        const { name: exchangeName, type, options } = exchange
        const { name: queueName, assertOptions, bindOptions } = queue
        const { consumeHandler, options: consumeOptions } = consume

        await channel.assertExchange(exchangeName, type, { durable: true, ...options })
        await channel.assertQueue(queueName, { durable: true, ...assertOptions })
        await channel.bindQueue(queueName, exchangeName, routingKey, { ...bindOptions })
        await channel.consume(
          queueName,
          async msg => {
            consumeHandler.apply(consume, [msg, { channel, exchange, queue }])
          },
          { ...consumeOptions, noAck: false }
        )
      })
    })

    await channelWrapper.waitForConnect()
    logger.info('----- mq Listening for messages')
  } catch (e) {
    logger.error(`consume 消息错误, ${vhost}, ${String.stringify(channelConfigs)}, ${e.stack}`)
  }
}
