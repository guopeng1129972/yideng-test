{"version":3,"sources":["../src/mqConsumers.js"],"names":["logger","global","console","getRandomFirstArray","arr","array","slice","i","Math","floor","random","length","randomOne","splice","concat","vhost","channelConfigs","amqpDomains","config","urls","map","amqpDomain","amqp","connect","connection","on","info","params","err","stack","channelWrapper","createChannel","forEach","exchange","queue","consume","routingKey","addSetup","channel","exchangeName","name","type","options","queueName","assertOptions","bindOptions","consumeHandler","consumeOptions","assertExchange","durable","assertQueue","bindQueue","msg","apply","noAck","waitForConnect","error","String","stringify"],"mappings":"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","file":"mqConsumers.js","sourcesContent":["import amqp from 'amqp-connection-manager'\nimport config from './config'\n\nconst logger = global.logger || console\n\nfunction getRandomFirstArray(arr) {\n  const array = arr.slice()\n  const i = Math.floor(Math.random() * (array.length))\n  const randomOne = array.splice(i, 1)\n  return [randomOne].concat(array)\n}\n\n/**\n * channelConfigs: [channelConfig]\n * channelConfig: {exchange: {name, type, options},\n * queue: {name, assertOptions, bindOptions}, consume: {consumeHandler, options}, routingKey}\n */\nexport default async ({ vhost, channelConfigs = [] }) => {\n  const { amqpDomains } = config\n  const urls = getRandomFirstArray(amqpDomains).map(amqpDomain => `${amqpDomain}/${vhost}`)\n\n  try {\n    const connection = await amqp.connect(urls)\n    connection.on('connect', () => logger.info(`Connected!-------rabbit mq in vhost ${vhost}`))\n    connection.on('disconnect', params => logger.info(`Disconnected-----rabbit mq in vhost ${vhost}`, params.err.stack))\n\n    const channelWrapper = connection.createChannel()\n\n    channelConfigs.forEach(({ exchange, queue, consume, routingKey }) => {\n      channelWrapper.addSetup(async channel => {\n        const { name: exchangeName, type, options } = exchange\n        const { name: queueName, assertOptions, bindOptions } = queue\n        const { consumeHandler, options: consumeOptions } = consume\n\n        await channel.assertExchange(exchangeName, type, { durable: true, ...options })\n        await channel.assertQueue(queueName, { durable: true, ...assertOptions })\n        await channel.bindQueue(queueName, exchangeName, routingKey, { ...bindOptions })\n        await channel.consume(\n          queueName,\n          async msg => {\n            consumeHandler.apply(consume, [msg, { channel, exchange, queue }])\n          },\n          { ...consumeOptions, noAck: false }\n        )\n      })\n    })\n\n    await channelWrapper.waitForConnect()\n    logger.info('----- mq Listening for messages')\n  } catch (e) {\n    logger.error(`consume 消息错误, ${vhost}, ${String.stringify(channelConfigs)}, ${e.stack}`)\n  }\n}\n"]}