'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _amqpConnectionManager = require('amqp-connection-manager');

var _amqpConnectionManager2 = _interopRequireDefault(_amqpConnectionManager);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var logger = global.logger || console;

function getRandomFirstArray(arr) {
  var array = arr.slice();
  var i = Math.floor(Math.random() * array.length);
  var randomOne = array.splice(i, 1);
  return [randomOne].concat(array);
}

/**
 * channelConfigs: [channelConfig]
 * channelConfig: {exchange: {name, type, options},
 * queue: {name, assertOptions, bindOptions}, consume: {consumeHandler, options}, routingKey}
 */

exports.default = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(_ref2) {
    var vhost = _ref2.vhost,
        _ref2$channelConfigs = _ref2.channelConfigs,
        channelConfigs = _ref2$channelConfigs === undefined ? [] : _ref2$channelConfigs;
    var amqpDomains, urls, connection, channelWrapper;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            amqpDomains = _config2.default.amqpDomains;
            urls = getRandomFirstArray(amqpDomains).map(function (amqpDomain) {
              return amqpDomain + '/' + vhost;
            });
            _context3.prev = 2;
            _context3.next = 5;
            return _amqpConnectionManager2.default.connect(urls);

          case 5:
            connection = _context3.sent;

            connection.on('connect', function () {
              return logger.info('Connected!-------rabbit mq in vhost ' + vhost);
            });
            connection.on('disconnect', function (params) {
              return logger.info('Disconnected-----rabbit mq in vhost ' + vhost, params.err.stack);
            });

            channelWrapper = connection.createChannel();


            channelConfigs.forEach(function (_ref3) {
              var exchange = _ref3.exchange,
                  queue = _ref3.queue,
                  consume = _ref3.consume,
                  routingKey = _ref3.routingKey;

              channelWrapper.addSetup(function () {
                var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(channel) {
                  var exchangeName, type, options, queueName, assertOptions, bindOptions, consumeHandler, consumeOptions;
                  return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          exchangeName = exchange.name, type = exchange.type, options = exchange.options;
                          queueName = queue.name, assertOptions = queue.assertOptions, bindOptions = queue.bindOptions;
                          consumeHandler = consume.consumeHandler, consumeOptions = consume.options;
                          _context2.next = 5;
                          return channel.assertExchange(exchangeName, type, (0, _extends3.default)({ durable: true }, options));

                        case 5:
                          _context2.next = 7;
                          return channel.assertQueue(queueName, (0, _extends3.default)({ durable: true }, assertOptions));

                        case 7:
                          _context2.next = 9;
                          return channel.bindQueue(queueName, exchangeName, routingKey, (0, _extends3.default)({}, bindOptions));

                        case 9:
                          _context2.next = 11;
                          return channel.consume(queueName, function () {
                            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(msg) {
                              return _regenerator2.default.wrap(function _callee$(_context) {
                                while (1) {
                                  switch (_context.prev = _context.next) {
                                    case 0:
                                      consumeHandler.apply(consume, [msg, { channel: channel, exchange: exchange, queue: queue }]);

                                    case 1:
                                    case 'end':
                                      return _context.stop();
                                  }
                                }
                              }, _callee, undefined);
                            }));

                            return function (_x3) {
                              return _ref5.apply(this, arguments);
                            };
                          }(), (0, _extends3.default)({}, consumeOptions, { noAck: false }));

                        case 11:
                        case 'end':
                          return _context2.stop();
                      }
                    }
                  }, _callee2, undefined);
                }));

                return function (_x2) {
                  return _ref4.apply(this, arguments);
                };
              }());
            });

            _context3.next = 12;
            return channelWrapper.waitForConnect();

          case 12:
            logger.info('----- mq Listening for messages');
            _context3.next = 18;
            break;

          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3['catch'](2);

            logger.error('consume \u6D88\u606F\u9519\u8BEF, ' + vhost + ', ' + String.stringify(channelConfigs) + ', ' + _context3.t0.stack);

          case 18:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, undefined, [[2, 15]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

module.exports = exports['default'];
//# sourceMappingURL=mqConsumers.js.map