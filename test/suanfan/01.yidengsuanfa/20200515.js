/**
 * 
 * //算法每日一练
 * //20200515
 * 运动范围地上有一个m行n列的方格
 * ，从坐标[0,0]到坐标[m-1,n-1]。
 * 一个机器人从坐标[0,0]的格子开始移动，它每次可以向左、右、上、下移动一格
 * （不能移动到方格外）,也不能进入行坐标和列坐标的每个数位之和大于k的格子。
 * 例如，当k为18时，机器人能够进入方格[35,37],因为3+5+3+7=18。
 * 但它不能进入方格[35,38],因为3+5+3+8=19。请问该机器人能够到达多少个格子？
 * 提示：1<=n,m<=1000<=k<=20
 * 参考答案：题目提到了数字的数位之和，这个利用取余运算即可，
 * 并将其单独封装函数。代码如下：
 * */
functionbitsum(n){
  let res = 0;
  while (n) {
    res = res + (n % 10);
    n = Math.floor(n / 10);
    return res;
  }
}
  /**要注意的是：能满足数位之和的要求的坐标，不一定能达到。
* 因为题目提到了机器人的移动是每次可以向上下左右4个方向移动一格，并且开始的坐标是（0,0)
例如当m=36,n=15,k=9时，由于只能向合法坐标移动1格，从（18,0)并不能到达(20,0),
即使（20,0)满足数位之和的条件。
这就需要使用深度优先遍历（DFS)或者广度优先遍历（BFS),而不是直接检查每个元素。
解法1:广度优先遍历（推荐）
和普通BFS相比，
有两点不同：需要调用bitSum来检查数位之和因为从左上角开始遍历，
因此只需要遍历「右」和「下」这两个方向代码如下：
*/